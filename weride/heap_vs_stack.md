# 堆 (Heap) vs 栈 (Stack): 内存管理深度解析

本文档详细阐述计算机内存模型中堆与栈的核心区别、底层原理、使用场景及在不同语言中的表现。

---

## 1. 核心区别 (Core Differences)

| 特性 | 栈 (Stack) | 堆 (Heap) |
| :--- | :--- | :--- |
| **分配速度** | **极快** (只需移动栈顶指针 `RSP`) | **较慢** (需在空闲链表中寻找合适大小的块) |
| **管理方式** | **自动管理** (OS/编译器负责，函数调用入栈，返回出栈) | **手动/GC 管理** (程序员或垃圾回收器负责) |
| **生命周期** | 随函数作用域结束而立即销毁 | 直到被显式释放或被 GC 回收 |
| **空间大小** | **小** (通常 1MB - 8MB，固定) | **大** (受物理内存限制，GB 级，动态) |
| **内存碎片** | **无** (严格连续 LIFO) | **有** (频繁分配释放导致空洞) |
| **线程安全** | **线程私有** (无需加锁) | **线程共享** (需加锁/同步机制) |
| **寻址方式** | 直接寻址 (Offset from Base Pointer `RBP`) | 间接寻址 (Pointer Dereference) |

---

## 2. 底层原理与分配机制

### 2.1 栈的分配 (Stack Allocation)
*   **指令级操作**:
    *   `push`: 压栈。`RSP` (栈顶指针) 减小，写入数据。
    *   `pop`: 出栈。读取数据，`RSP` 增加。
    *   `sub rsp, N`: 一次性分配 N 字节的栈帧 (Stack Frame) 空间。
*   **栈帧结构**:
    *   包含：**返回地址 (Return Address)**, **参数 (Arguments)**, **局部变量 (Local Variables)**, **保存的寄存器 (Saved Registers)**。
*   **缓存友好 (Cache Friendly)**:
    *   栈内存是连续的，且最近访问的数据往往在栈顶 (Hot)，极易命中 CPU L1/L2 Cache。

### 2.2 堆的分配 (Heap Allocation)
*   **系统调用**:
    *   OS 提供 `brk/sbrk` (调整 Data Segment) 或 `mmap` (匿名映射) 来扩充堆空间。
    *   Allocator (如 `malloc`, `tcmalloc`, `jemalloc`) 管理这些大块内存，切割成小块分给用户。
*   **空闲链表 (Free List)**:
    *   维护未使用的内存块列表。分配时需遍历链表找到足够大的块 (First Fit / Best Fit)，可能涉及分割块和合并块。
*   **碎片问题**:
    *   长期运行后，内存可能变成许多不可用的小碎片。需配合 GC 的 Compacting 算法整理。

---

## 3. 使用场景 (When to use What)

### 3.1 栈的最佳场景
*   **小数据**: `int`, `bool`, `struct` (小结构体)。
*   **生命周期短**: 只在当前函数内使用，不需要跨函数传递 (返回指针除外)。
*   **高性能要求**: **栈分配几乎零开销**，且无 GC 压力。

### 3.2 堆的最佳场景
*   **大数据**: 大数组、大对象、图片、文件缓冲。
*   **动态大小**: 编译期无法确定大小的数据 (如读取用户输入生成的 List)。
*   **长生命周期**: 数据需要在函数返回后依然存在，或者在多个线程间共享。
*   **接口/多态**: 需要通过基类指针操作子类对象 (主要在 C++ 中)。

---

## 4. 语言特性与逃逸分析 (Escape Analysis)

### 4.1 C/C++
*   **显式控制**:
    *   `int a;` -> 栈。
    *   `int* p = new int;` -> 堆。
*   **常见错误**:
    *   **Dangling Pointer**: 返回栈变量的地址。`return &local_var;` (函数返回后栈帧销毁，指针指向非法区域)。
    *   **Memory Leak**: `new` 了没 `delete`。

### 4.2 Java
*   **一切皆对象 (几乎)**:
    *   **对象实例 (`new Object()`)**: 几乎总是分配在 **堆** 上。
    *   **引用 (`Object o`)**: 引用本身 (指针) 在栈上。
    *   **基本类型 (`int`, `boolean`)**: 局部变量在栈上。
*   **逃逸分析优化 (JIT)**:
    *   如果 JIT 发现一个对象只在方法内部使用，未逃逸出去，可能进行 **标量替换 (Scalar Replacement)**，将对象拆解成若干基本类型变量**分配在栈上**，完全避免 GC。

### 4.3 Go (Golang)
*   **编译器自动决定**:
    *   开发者无需关心 `new` 到底在堆还是栈。
    *   `var x int` 或 `p := new(int)` 都可能在堆或栈。
*   **逃逸分析规则**:
    *   如果 `&x` 被返回，或者赋值给了全局变量/堆对象，`x` **逃逸**到堆。
    *   如果 `x` 很大 (如 `make([]byte, 1000000)`), 逃逸到堆。
    *   **优化技巧**: 尽量避免不必要的指针传递 (Go 也是值传递)，让变量留在栈上，减轻 GC 扫描压力。

### 4.4 Python
*   **全堆模型**:
    *   Python 的 `int`, `str` 都是对象 (PyObject)，都分配在堆上。
    *   栈上只存储对象的引用 (指针)。

---

### 4.5 C# (.NET)
*   **值类型 vs 引用类型 (Value vs Reference Types)**:
    *   **struct, enum, int**: **值类型**。通常分配在**栈**上 (除非它是 class 的字段)。
    *   **class, interface, delegate, string**: **引用类型**。实例分配在**堆**上，引用指针在栈上。
*   **高性能黑科技**:
    *   **stackalloc**: `Span<int> numbers = stackalloc int[100];`。在栈上直接分配数组，无 GC 开销。
    *   **ref struct**: 强制**只能**在栈上分配 (如 `Span<T>`)，防止逃逸到堆，保证内存安全。
    *   **Box/Unbox (装箱/拆箱)**: 将值类型转为引用类型 (object) 会导致堆分配 (装箱)，应尽量使用泛型避免之。

---

## 5. 常见异常 (Exceptions)

### 5.1 StackOverflowError
*   **原因**:
    *   **无限递归**: 如果没有终止条件，不断压栈，消耗完栈空间。
    *   **超大局部变量**: 在栈上申请了巨大的数组 (C语言常见)。
*   **解法**: 检查递归逻辑，该用循环；将大数组移到堆 (`malloc`/`new`)。

### 5.2 OutOfMemoryError (OOM)
*   **原因**:
    *   **堆溢出**: 申请的对象总和超过了 heap size limit。
    *   **内存泄漏**: 对象不再使用但仍被引用，GC 无法回收。
*   **解法**: 增大堆限制 (`-Xmx`)，分析 Heap Dump 找泄漏点，优化数据结构。
